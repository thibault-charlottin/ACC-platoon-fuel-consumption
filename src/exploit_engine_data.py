import pandas as pd
import os
import numpy as np
from scipy.integrate import trapz
from scipy import stats as stats
from sklearn.metrics import mean_squared_error
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.api as sm
import statsmodels.formula.api as smf

def rename_data(path,out_path,equivalence_table):
    """This function reshape the data name from the one extracted out of the engine to standardized csv names"""
    filelist = sorted(os.listdir(path))
    equivalence_table = equivalence_table.sort_values(by='filename')
    count = 0
    for k in filelist : 
        for l in range(len(equivalence_table['filename'])) :
            if k==equivalence_table['filename'][l] : 
                test_file = sorted(os.listdir(out_path))
                outfile = equivalence_table['OpenACC_Equivalence'][l]+'.csv'
                if outfile in test_file : 

                    if equivalence_table['OpenACC_Equivalence'][l]+'_sample_2.csv' not in test_file :
                        count+=1
                        outfile = equivalence_table['OpenACC_Equivalence'][l]+'_sample_2.csv'
                    else : 
                        outfile = equivalence_table['OpenACC_Equivalence'][l]+'_sample_3.csv'
                data = pd.read_csv(path+k,delimiter = ' ')
                data.columns = ['time', 'speed','OpenACC_recorded_speed','gearbox','fuel_rate','fuel_density']
                data.to_csv(out_path+outfile)
    return test_file


def import_results(path,file):
    """import results and add a distance array that outputs temporal evolution of this indicator
    out columns : time,speed,OpenACC_recorded_speed,gearbox,fuel_rate,fuel_density """
    data = pd.read_csv(path+file)
    distance_array = [0]
    for k in range(1,len(data['speed'])) : 
        distance_array.append(distance_array[k-1]+data['speed'][k])
    data['distance'] = distance_array
    return data

def compute_consumption(dataframe):
    """computes mean consumption of one recording
    used formula is presented in the article"""
    fuel_density = np.mean(dataframe['fuel_density'])
    tsim = np.array(dataframe['time'])
    dcarb = np.array(dataframe['fuel_rate'])
    speed = np.array(dataframe['speed'])
    conso100 = 100 * trapz(dcarb, tsim) / (trapz(speed, tsim)) / fuel_density
    return conso100

def compute_co2_emission(dataframe,MOTH_co2carb):
    """computes mean CO2 emission of one recording"""
    distance = list(dataframe['distance'])[-1]
    tsim = np.array(dataframe['time'])
    dcarb = np.array(dataframe['fuel_rate'])
    speed = np.array(dataframe['speed']*3.6)
    co2_gkm = 44 * trapz(dcarb, tsim) / (12 + MOTH_co2carb) / (distance/1000)
    return co2_gkm

def compute_consumption_emission(results_path,setting,MOTH_co2carb,veh_list):
    """compute for every recording with a specific time gap mean consumption and emission
    returns a dataframe that compiles position, setting, consumption (L/100km) and CO2 emission"""
    listfiles = sorted(os.listdir(results_path))
    conso_list = []
    co2_list = []
    for k in listfiles : 
        if setting in k :
            data = import_results(results_path,k)
            conso_list.append(compute_consumption(data))
            co2_list.append(compute_co2_emission(data,MOTH_co2carb))
    if setting == 'no_ACC' : 
        setting = 'HDV'
    df_out = pd.DataFrame({'position in platoon': veh_list,'setting':[setting for k in range(len(veh_list))],'consumption':conso_list,'CO2 emission' : co2_list}) 
    return df_out


def compute_df_emission_consumption(results_path,setting_list,MOTH_co2carb,veh_list):
    """using above function
    creates a dataframe that compiles all data about consumption and emission that are computed above"""
    df = pd.DataFrame({'position in platoon': [],'setting':[],'consumption':[],'CO2 emission' : []}) 
    for k in range(len(setting_list)):
        data = compute_consumption_emission(results_path,setting_list[k],MOTH_co2carb,veh_list[k])
        df = pd.concat([df,data], sort = False)
    return df

def compute_regular_regression(df_results):
    '''run linear regression consumption vs platoon position
    using statsmodel ols method  '''
    data = df_results
    data.columns = ['position','setting','consumption','CO2_emission']
    md = smf.ols("consumption~position *setting", data)
    mdf = md.fit()
    return mdf

def compute_regression_mixedlm(df,REML, formula):
    """run mixed effects LM where the consumption on the vehicles of the same platoon and position are 
    grouped together
    if REML = True algortihm is run using REML method
    If False algorithm is run using ML method"""
    data =df
    data.columns = ['position','setting','consumption','CO2_emission']
    data["grp"] = data["setting"].astype(str) + data["position"].astype(str)
    md = smf.mixedlm(formula, data, groups=data["grp"])
    mdf = md.fit(reml = REML)
    del(data['grp'])
    return mdf

def compute_mixedLM_specific_case(df, REML, formula):
    """run mixed effect model usiong a defined dataframe and a custom command
    if REML = True algortihm is run using REML method
    If False algorithm is run using ML method"""
    data = df
    data["grp"] = data["setting"].astype(str) + data["position"].astype(str)

    md = smf.mixedlm(formula, data, groups=data["grp"])
    mdf = md.fit(reml=REML)
    return mdf

