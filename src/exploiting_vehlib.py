import pandas as pd
import numpy as np
from scipy.integrate import trapz
from dtaidistance import dtw
from dtaidistance import dtw_visualisation as dtwvis
import os
from scipy import stats as stats
import statsmodels.api as sm
import statsmodels.formula.api as smf

def import_results(path,file):
    """import VEHLIB output files"""
    data = pd.read_csv(path+file)
    data.columns =['time', 'speed (km/h)','acceleration(km/h2)','distance (m)','instant power','instant consumption']
    return data

def examine_sim_validity(pathinit,pathsim,file,plotting) : 
    """compare VEHLIB estimated speed and OpenACC reccorded speed"""
    df1 = pd.read_csv(pathinit+file)
    df2 = pd.read_csv(pathsim+file)
    TIMEA,SPEEDA = df1['Time'],df1['Speed']
    TIMEB, SPEEDB = df2['time'],df2['speed']/3.6
    d, paths = dtw.warping_paths(SPEEDA, SPEEDB, window=25, psi=2)
    best_path = dtw.best_path(paths)
    if plotting == True :
        dtwvis.plot_warpingpaths(SPEEDA, SPEEDB, paths, best_path)
    return d

def compute_consumption(dataframe,fuel_density):
    """Compute the estimated mean consumption per 100km"""
    tsim = np.array(dataframe['time'])
    dcarb = np.array(dataframe['instant consumption'])
    speed = np.array(dataframe['speed (km/h)']/3.6)
    conso100 = 100 * trapz(dcarb, tsim) / (trapz(speed, tsim)/1000) / fuel_density
    return conso100

def compute_co2_emission(dataframe,MOTH_co2carb):
    """compute the total CO2 emission"""
    distance = list(dataframe['distance (m)'])[-1]
    tsim = np.array(dataframe['time'])
    dcarb = np.array(dataframe['instant consumption'])
    speed = np.array(dataframe['speed (km/h)'])
    co2_gkm = 44 * trapz(dcarb, tsim) / (12 + MOTH_co2carb) / (distance/1000)
    return co2_gkm

def compute_consumption_emission(results_path,setting,MOTH_co2carb,veh_list):
    """compute for every recording with a specific time gap mean consumption and emission
    returns a dataframe that compiles position, setting, consumption (L/100km) and CO2 emission"""
    listfiles = sorted(os.listdir(results_path))
    conso_list = []
    co2_list = []
    for k in listfiles : 
        if setting in k :
            data = import_results(results_path,k)
            conso_list.append(compute_consumption(data))
            co2_list.append(compute_co2_emission(data,MOTH_co2carb))
    df_out = pd.DataFrame({'position in platoon': veh_list,'setting':[setting for k in range(len(veh_list))],'consumption':conso_list,'CO2 emission' : co2_list}) 
    return df_out


def compute_df_emission_consumption(results_path,setting_list,MOTH_co2carb,veh_list):
    """using above function
    creates a dataframe that compiles all data about consumption and emission that are computed above"""
    df = pd.DataFrame({'position in platoon': [],'setting':[],'consumption':[],'CO2 emission' : []}) 
    for k in range(len(setting_list)):
        data = compute_consumption_emission(results_path,setting_list[k],MOTH_co2carb,veh_list[k])
        df = pd.concat([df,data], sort = False)
    return df

def compute_regression(df_results, setting):
    """run miwedLM where the consumption on the vehicles of the same platoon and position are 
    grouped together"""
    data = df_results[df_results['setting']==setting]
    data.columns = ['position','setting','consumption','CO2_emission']
    md = smf.mixedlm("consumption~position", data, groups=data["position"], re_formula='~position')
    mdf = md.fit()
    return mdf