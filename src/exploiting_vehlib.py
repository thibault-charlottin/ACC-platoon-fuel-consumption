import pandas as pd
import numpy as np
from scipy.integrate import trapz
from dtaidistance import dtw
from dtaidistance import dtw_visualisation as dtwvis
import os
from scipy import stats as stats
from sklearn.metrics import mean_squared_error

def import_results(path,file):
    data = pd.read_csv(path+file)
    data.columns =['time', 'speed (km/h)','acceleration(km/h2)','distance (m)','instant power','instant consumption']
    return data

def examine_sim_validity(pathinit,pathsim,file,plotting) : 
    df1 = pd.read_csv(pathinit+file)
    df2 = pd.read_csv(pathsim+file)
    TIMEA,SPEEDA = df1['Time'],df1['Speed']
    TIMEB, SPEEDB = df2['time'],df2['speed']/3.6
    d, paths = dtw.warping_paths(SPEEDA, SPEEDB, window=25, psi=2)
    best_path = dtw.best_path(paths)
    if plotting == True :
        dtwvis.plot_warpingpaths(SPEEDA, SPEEDB, paths, best_path)
    return d

def compute_consumption(dataframe,fuel_density):
    tsim = np.array(dataframe['time'])
    dcarb = np.array(dataframe['instant consumption'])
    speed = np.array(dataframe['speed (km/h)']/3.6)
    conso100 = 100 * trapz(dcarb, tsim) / (trapz(speed, tsim)/1000) / fuel_density
    return conso100

def compute_co2_emission(dataframe,MOTH_co2carb):
    distance = list(dataframe['distance (m)'])[-1]
    tsim = np.array(dataframe['time'])
    dcarb = np.array(dataframe['instant consumption'])
    speed = np.array(dataframe['speed (km/h)'])
    co2_gkm = 44 * trapz(dcarb, tsim) / (12 + MOTH_co2carb) / (distance/1000)
    return co2_gkm

def compute_consumption_regression(results_path,speed,setting,fuel_density):
    results_path = 'Vehlib_results/consumption/'
    listfiles = sorted(os.listdir(results_path))
    conso_list = []
    veh_list = []
    for k in listfiles : 
        if speed in k and setting in k :
            data = import_results(results_path,k)
            conso_list.append(compute_consumption(data,fuel_density))
            veh_list.append(int(k[-5]))
    veh_list_computation = np.array([k for k in range(len(conso_list))])
    slope, intercept, _, _, _ = stats.linregress(veh_list,conso_list)  
    y_pred = intercept + slope * veh_list_computation
    RMSE = mean_squared_error(conso_list, y_pred)    
    return np.array([int(len(veh_list)),slope, intercept, RMSE])

def compute_CO2_regression(results_path,speed,setting,MOTH_co2carb):
    results_path = 'Vehlib_results/consumption/'
    listfiles = sorted(os.listdir(results_path))
    conso_list = []
    veh_list = []
    for k in listfiles : 
        if speed in k and setting in k :
            data = import_results(results_path,k)
            conso_list.append(compute_co2_emission(data,MOTH_co2carb))
    veh_list_computation = np.array([k for k in range(len(conso_list))])
    slope, intercept, _, _, _ = stats.linregress(veh_list,conso_list)  
    y_pred = intercept + slope * veh_list_computation
    RMSE = mean_squared_error(conso_list, y_pred)    
    return np.array([int(len(veh_list)),slope, intercept, RMSE])

def test_null_regression(results_path,speed,setting,fuel_density):
    listfiles = sorted(os.listdir(results_path))
    conso_list = []
    veh_list = []
    for k in listfiles : 
        if speed in k and setting in k :
            data = import_results(results_path,k)
            conso_list.append(compute_consumption(data,fuel_density))
    test_array = np.array([min(conso_list)+0.1*k for k in range (10) if k<max(conso_list)])
    RMSE_list = []
    for k in test_array :
        array_model = np.array([k for j in range(len(conso_list))])
        RMSE_list.append(mean_squared_error(conso_list, array_model))
    return min(RMSE_list)

    